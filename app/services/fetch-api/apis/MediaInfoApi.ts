/* tslint:disable */
/* eslint-disable */
/**
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    DeviceProfileDto,
    DeviceProfileDtoFromJSON,
    DeviceProfileDtoToJSON,
    LiveStreamResponse,
    LiveStreamResponseFromJSON,
    LiveStreamResponseToJSON,
    OpenLiveStreamDto,
    OpenLiveStreamDtoFromJSON,
    OpenLiveStreamDtoToJSON,
    PlaybackInfoResponse,
    PlaybackInfoResponseFromJSON,
    PlaybackInfoResponseToJSON,
    ProblemDetails,
    ProblemDetailsFromJSON,
    ProblemDetailsToJSON,
} from '../models';

export interface CloseLiveStreamRequest {
    liveStreamId: string;
}

export interface GetBitrateTestBytesRequest {
    size?: number;
}

export interface GetPlaybackInfoRequest {
    itemId: string;
    userId: string;
}

export interface GetPostedPlaybackInfoRequest {
    itemId: string;
    userId?: string | null;
    maxStreamingBitrate?: number | null;
    startTimeTicks?: number | null;
    audioStreamIndex?: number | null;
    subtitleStreamIndex?: number | null;
    maxAudioChannels?: number | null;
    mediaSourceId?: string | null;
    liveStreamId?: string | null;
    autoOpenLiveStream?: boolean;
    enableDirectPlay?: boolean;
    enableDirectStream?: boolean;
    enableTranscoding?: boolean;
    allowVideoStreamCopy?: boolean;
    allowAudioStreamCopy?: boolean;
    deviceProfileDto?: DeviceProfileDto;
}

export interface OpenLiveStreamRequest {
    openToken?: string | null;
    userId?: string | null;
    playSessionId?: string | null;
    maxStreamingBitrate?: number | null;
    startTimeTicks?: number | null;
    audioStreamIndex?: number | null;
    subtitleStreamIndex?: number | null;
    maxAudioChannels?: number | null;
    itemId?: string | null;
    enableDirectPlay?: boolean;
    enableDirectStream?: boolean;
    openLiveStreamDto?: OpenLiveStreamDto;
}

/**
 * 
 */
export class MediaInfoApi extends runtime.BaseAPI {

    /**
     * Closes a media source.
     */
    async closeLiveStreamRaw(requestParameters: CloseLiveStreamRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.liveStreamId === null || requestParameters.liveStreamId === undefined) {
            throw new runtime.RequiredError('liveStreamId','Required parameter requestParameters.liveStreamId was null or undefined when calling closeLiveStream.');
        }

        const queryParameters: any = {};

        if (requestParameters.liveStreamId !== undefined) {
            queryParameters['liveStreamId'] = requestParameters.liveStreamId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Emby-Authorization"] = this.configuration.apiKey("X-Emby-Authorization"); // CustomAuthentication authentication
        }

        const response = await this.request({
            path: `/LiveStreams/Close`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Closes a media source.
     */
    async closeLiveStream(requestParameters: CloseLiveStreamRequest): Promise<void> {
        await this.closeLiveStreamRaw(requestParameters);
    }

    /**
     * Tests the network with a request with the size of the bitrate.
     */
    async getBitrateTestBytesRaw(requestParameters: GetBitrateTestBytesRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Emby-Authorization"] = this.configuration.apiKey("X-Emby-Authorization"); // CustomAuthentication authentication
        }

        const response = await this.request({
            path: `/Playback/BitrateTest`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Tests the network with a request with the size of the bitrate.
     */
    async getBitrateTestBytes(requestParameters: GetBitrateTestBytesRequest): Promise<any> {
        const response = await this.getBitrateTestBytesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets live playback media info for an item.
     */
    async getPlaybackInfoRaw(requestParameters: GetPlaybackInfoRequest): Promise<runtime.ApiResponse<PlaybackInfoResponse>> {
        if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
            throw new runtime.RequiredError('itemId','Required parameter requestParameters.itemId was null or undefined when calling getPlaybackInfo.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getPlaybackInfo.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['userId'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Emby-Authorization"] = this.configuration.apiKey("X-Emby-Authorization"); // CustomAuthentication authentication
        }

        const response = await this.request({
            path: `/Items/{itemId}/PlaybackInfo`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PlaybackInfoResponseFromJSON(jsonValue));
    }

    /**
     * Gets live playback media info for an item.
     */
    async getPlaybackInfo(requestParameters: GetPlaybackInfoRequest): Promise<PlaybackInfoResponse> {
        const response = await this.getPlaybackInfoRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets live playback media info for an item.
     */
    async getPostedPlaybackInfoRaw(requestParameters: GetPostedPlaybackInfoRequest): Promise<runtime.ApiResponse<PlaybackInfoResponse>> {
        if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
            throw new runtime.RequiredError('itemId','Required parameter requestParameters.itemId was null or undefined when calling getPostedPlaybackInfo.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['userId'] = requestParameters.userId;
        }

        if (requestParameters.maxStreamingBitrate !== undefined) {
            queryParameters['maxStreamingBitrate'] = requestParameters.maxStreamingBitrate;
        }

        if (requestParameters.startTimeTicks !== undefined) {
            queryParameters['startTimeTicks'] = requestParameters.startTimeTicks;
        }

        if (requestParameters.audioStreamIndex !== undefined) {
            queryParameters['audioStreamIndex'] = requestParameters.audioStreamIndex;
        }

        if (requestParameters.subtitleStreamIndex !== undefined) {
            queryParameters['subtitleStreamIndex'] = requestParameters.subtitleStreamIndex;
        }

        if (requestParameters.maxAudioChannels !== undefined) {
            queryParameters['maxAudioChannels'] = requestParameters.maxAudioChannels;
        }

        if (requestParameters.mediaSourceId !== undefined) {
            queryParameters['mediaSourceId'] = requestParameters.mediaSourceId;
        }

        if (requestParameters.liveStreamId !== undefined) {
            queryParameters['liveStreamId'] = requestParameters.liveStreamId;
        }

        if (requestParameters.autoOpenLiveStream !== undefined) {
            queryParameters['autoOpenLiveStream'] = requestParameters.autoOpenLiveStream;
        }

        if (requestParameters.enableDirectPlay !== undefined) {
            queryParameters['enableDirectPlay'] = requestParameters.enableDirectPlay;
        }

        if (requestParameters.enableDirectStream !== undefined) {
            queryParameters['enableDirectStream'] = requestParameters.enableDirectStream;
        }

        if (requestParameters.enableTranscoding !== undefined) {
            queryParameters['enableTranscoding'] = requestParameters.enableTranscoding;
        }

        if (requestParameters.allowVideoStreamCopy !== undefined) {
            queryParameters['allowVideoStreamCopy'] = requestParameters.allowVideoStreamCopy;
        }

        if (requestParameters.allowAudioStreamCopy !== undefined) {
            queryParameters['allowAudioStreamCopy'] = requestParameters.allowAudioStreamCopy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Emby-Authorization"] = this.configuration.apiKey("X-Emby-Authorization"); // CustomAuthentication authentication
        }

        const response = await this.request({
            path: `/Items/{itemId}/PlaybackInfo`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeviceProfileDtoToJSON(requestParameters.deviceProfileDto),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PlaybackInfoResponseFromJSON(jsonValue));
    }

    /**
     * Gets live playback media info for an item.
     */
    async getPostedPlaybackInfo(requestParameters: GetPostedPlaybackInfoRequest): Promise<PlaybackInfoResponse> {
        const response = await this.getPostedPlaybackInfoRaw(requestParameters);
        return await response.value();
    }

    /**
     * Opens a media source.
     */
    async openLiveStreamRaw(requestParameters: OpenLiveStreamRequest): Promise<runtime.ApiResponse<LiveStreamResponse>> {
        const queryParameters: any = {};

        if (requestParameters.openToken !== undefined) {
            queryParameters['openToken'] = requestParameters.openToken;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['userId'] = requestParameters.userId;
        }

        if (requestParameters.playSessionId !== undefined) {
            queryParameters['playSessionId'] = requestParameters.playSessionId;
        }

        if (requestParameters.maxStreamingBitrate !== undefined) {
            queryParameters['maxStreamingBitrate'] = requestParameters.maxStreamingBitrate;
        }

        if (requestParameters.startTimeTicks !== undefined) {
            queryParameters['startTimeTicks'] = requestParameters.startTimeTicks;
        }

        if (requestParameters.audioStreamIndex !== undefined) {
            queryParameters['audioStreamIndex'] = requestParameters.audioStreamIndex;
        }

        if (requestParameters.subtitleStreamIndex !== undefined) {
            queryParameters['subtitleStreamIndex'] = requestParameters.subtitleStreamIndex;
        }

        if (requestParameters.maxAudioChannels !== undefined) {
            queryParameters['maxAudioChannels'] = requestParameters.maxAudioChannels;
        }

        if (requestParameters.itemId !== undefined) {
            queryParameters['itemId'] = requestParameters.itemId;
        }

        if (requestParameters.enableDirectPlay !== undefined) {
            queryParameters['enableDirectPlay'] = requestParameters.enableDirectPlay;
        }

        if (requestParameters.enableDirectStream !== undefined) {
            queryParameters['enableDirectStream'] = requestParameters.enableDirectStream;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Emby-Authorization"] = this.configuration.apiKey("X-Emby-Authorization"); // CustomAuthentication authentication
        }

        const response = await this.request({
            path: `/LiveStreams/Open`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenLiveStreamDtoToJSON(requestParameters.openLiveStreamDto),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LiveStreamResponseFromJSON(jsonValue));
    }

    /**
     * Opens a media source.
     */
    async openLiveStream(requestParameters: OpenLiveStreamRequest): Promise<LiveStreamResponse> {
        const response = await this.openLiveStreamRaw(requestParameters);
        return await response.value();
    }

}
